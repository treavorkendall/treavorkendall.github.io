<!DOCTYPE html>
<html>
<head>
    <title>3D Torso - Stress & Torsion Analysis</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0a0a0a; font-family: sans-serif; }
        #ui { 
            position: absolute; top: 10px; left: 10px; color: white; 
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px;
            pointer-events: none; line-height: 1.5; border: 1px solid #444;
        }
        kbd { background: #333; border-radius: 3px; padding: 1px 4px; border: 1px solid #666; }
    </style>
</head>
<body>
    <div id="ui">
        <b>Biomechanical Analysis:</b><br>
        • <kbd>W</kbd> Move | <kbd>E</kbd> Rotate<br>
        • <span style="color: #ff5555;">Red Glow</span> = Excessive Stretch or Twist<br>
        • <span style="color: #ffff00;">Yellow Poles</span> indicate anatomical vertical
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GUI } from 'lil-gui';

        // --- Constants ---
        const START_Y_TOP = 1.4;
        const START_Y_BOT = -1.0;
        const DEFAULT_FLATNESS = 1.2;
        const STRESS_LIMIT_DIST = 5.5; 
        const STRESS_LIMIT_ROT = 0.8; // ~45 degrees

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 7);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 2.5);
        light.position.set(5, 10, 7);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x505050));

        const createSphereGroup = (yPos, color, name) => {
            const group = new THREE.Group();
            group.name = name;
            
            const mesh = new THREE.Mesh(
                new THREE.SphereGeometry(1, 32, 32),
                new THREE.MeshStandardMaterial({ color: color, roughness: 0.7, transparent: true, opacity: 0.9 })
            );
            mesh.scale.y = DEFAULT_FLATNESS;
            group.add(mesh);

            const ringGeo = new THREE.TorusGeometry(1, 0.01, 16, 100);
            const eq = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            eq.rotation.x = Math.PI/2;
            group.add(eq);

            const mer = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ color: 0x0000ff }));
            mer.rotation.y = Math.PI/2;
            group.add(mer);

            const poleGeo = new THREE.SphereGeometry(0.06, 12, 12);
            const poleMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const nP = new THREE.Mesh(poleGeo, poleMat); group.add(nP);
            const sP = new THREE.Mesh(poleGeo, poleMat); group.add(sP);

            group.position.y = yPos;
            scene.add(group);
            return group;
        };

        const sphere1 = createSphereGroup(START_Y_TOP, 0xdddddd, "Ribs");
        const sphere2 = createSphereGroup(START_Y_BOT, 0xaaaaaa, "Pelvis");

        // --- Dynamic Sock ---
        const sockSegments = 40;
        const sockRadialSegments = 24;
        const sockGeo = new THREE.PlaneGeometry(1, 1, sockRadialSegments, sockSegments);
        const sockMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.5, 
            side: THREE.DoubleSide,
            emissiveIntensity: 1.0
        });
        const sockMesh = new THREE.Mesh(sockGeo, sockMat);
        scene.add(sockMesh);

        function updateSock() {
            const posAttr = sockGeo.attributes.position;
            const p1 = new THREE.Vector3(), p2 = new THREE.Vector3();
            sphere1.getWorldPosition(p1);
            sphere2.getWorldPosition(p2);

            const q1 = new THREE.Quaternion(), q2 = new THREE.Quaternion();
            sphere1.getWorldQuaternion(q1);
            sphere2.getWorldQuaternion(q2);

            // 1. Stress Detection
            const dist = p1.distanceTo(p2);
            const angleDiff = q1.angleTo(q2);

            if (dist > STRESS_LIMIT_DIST || angleDiff > STRESS_LIMIT_ROT) {
                sockMat.color.set(0xff0000);
                sockMat.emissive.set(0x440000);
            } else {
                sockMat.color.set(0xffffff);
                sockMat.emissive.set(0x000000);
            }

            // 2. Anatomical Updates (Poles & Meridian Scale)
            sphere1.children[3].position.y = params.s1Flat;
            sphere1.children[4].position.y = -params.s1Flat;
            sphere1.children[2].scale.set(1, params.s1Flat, 1);
            sphere2.children[3].position.y = params.s2Flat;
            sphere2.children[4].position.y = -params.s2Flat;
            sphere2.children[2].scale.set(1, params.s2Flat, 1);

            // 3. Path Calculation
            const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
            const hDist = Math.abs(p1.x - p2.x) + Math.abs(p1.z - p2.z);
            mid.y -= (hDist + 0.1) * 0.3; 
            mid.x += params.manualSag;
            mid.z += 0.0001; // Numerical stability fix for reset

            const curve = new THREE.CatmullRomCurve3([p1, mid, p2]);
            const points = curve.getPoints(sockSegments);
            
            for (let i = 0; i <= sockSegments; i++) {
                const t = i / sockSegments;
                const center = points[i];
                const currentRot = new THREE.Quaternion().slerpQuaternions(q1, q2, t);
                
                const tangent = curve.getTangent(t).normalize();
                const upVector = new THREE.Vector3(0, 0, 1).applyQuaternion(currentRot);
                const normal = new THREE.Vector3().crossVectors(tangent, upVector).normalize();
                const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();

                for (let j = 0; j <= sockRadialSegments; j++) {
                    const rAngle = (j / sockRadialSegments) * Math.PI * 2;
                    const vertex = new THREE.Vector3()
                        .copy(center)
                        .add(normal.clone().multiplyScalar(Math.cos(rAngle) * 1.07))
                        .add(binormal.clone().multiplyScalar(Math.sin(rAngle) * 1.07));
                    posAttr.setXYZ(i * (sockRadialSegments + 1) + j, vertex.x, vertex.y, vertex.z);
                }
            }
            posAttr.needsUpdate = true;
        }

        const gui = new GUI();
        const params = {
            s1Flat: DEFAULT_FLATNESS, s2Flat: DEFAULT_FLATNESS, manualSag: 0.0,
            reset: () => {
                sphere1.position.set(0, START_Y_TOP, 0);
                sphere2.position.set(0, START_Y_BOT, 0);
                sphere1.rotation.set(0, 0, 0);
                sphere2.rotation.set(0, 0, 0);
                sphere1.children[0].scale.y = DEFAULT_FLATNESS;
                sphere2.children[0].scale.y = DEFAULT_FLATNESS;
                params.s1Flat = DEFAULT_FLATNESS; params.s2Flat = DEFAULT_FLATNESS; params.manualSag = 0;
                gui.controllers.forEach(c => c.updateDisplay());
                transform.detach();
                updateSock();
            }
        };

        gui.add(params, 's1Flat', 0.5, 2).name('Rib Flatness').onChange(v => sphere1.children[0].scale.y = v);
        gui.add(params, 's2Flat', 0.5, 2).name('Pelvis Flatness').onChange(v => sphere2.children[0].scale.y = v);
        gui.add(params, 'manualSag', -1, 1).name('Sag Offset');
        gui.add(params, 'reset').name('Reset Anatomy');

        const orbit = new OrbitControls(camera, renderer.domElement);
        const transform = new TransformControls(camera, renderer.domElement);
        scene.add(transform);
        transform.addEventListener('dragging-changed', (e) => orbit.enabled = !e.value);

        window.addEventListener('mousedown', (e) => {
            if (e.target.closest('.lil-gui')) return;
            const mouse = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
            const ray = new THREE.Raycaster();
            ray.setFromCamera(mouse, camera);
            const hits = ray.intersectObjects([sphere1, sphere2], true);
            if (hits.length > 0) {
                let t = hits[0].object;
                while (t.parent && t.type !== 'Group') t = t.parent;
                transform.attach(t);
            } else if (!transform.dragging) transform.detach();
        });

        window.addEventListener('keydown', (e) => {
            if (e.key === 'w') transform.setMode('translate');
            if (e.key === 'e') transform.setMode('rotate');
            if (e.key === 'Escape') transform.detach();
        });

        function animate() {
            requestAnimationFrame(animate);
            updateSock(); 
            orbit.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>